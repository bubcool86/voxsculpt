<!doctype html>
<html>
<head>
    <title>Voxsculpt</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <link rel="stylesheet" type="text/css" href="style.css">
    <script src="dat.gui.min.js" type="text/javascript"></script>
    <script src="gl-matrix-min.js" type="text/javascript"></script>
    
    <script src="texture.js" type="text/javascript"></script>
    <script src="framebuffer.js" type="text/javascript"></script>
    <script src="material.js" type="text/javascript"></script>
    <script src="voxsculpt.js" type="text/javascript"></script>



    <!-- Fragment shader program -->

    <script id="cubeframe-fs" type="x-shader/x-fragment">
        varying highp vec3 vObjNormal;
        varying highp vec3 vColor;

        varying highp vec3 vPosition;
        varying highp vec2 vUV;

        uniform highp float cubeSize;

        void main(void) {
            highp vec4 texelColor;
                      
            bool onEdgeX = ( vObjNormal.x > 0.5 && vObjNormal.x < 0.9 ) || ( vObjNormal.x < -0.5 && vObjNormal.x > -0.9 );
            bool onEdgeY = ( vObjNormal.y > 0.5 && vObjNormal.y < 0.9 ) || ( vObjNormal.y < -0.5 && vObjNormal.y > -0.9 );
            bool onEdgeZ = ( vObjNormal.z > 0.5 && vObjNormal.z < 0.9 ) || ( vObjNormal.z < -0.5 && vObjNormal.z > -0.9 );
            
            if(onEdgeX && onEdgeZ || onEdgeX && onEdgeY || onEdgeY && onEdgeZ )
            {
                texelColor.rgb = vPosition / 256.0;
                texelColor.a = 1.0;
            }
            else
            {
                discard;
            }
            
            gl_FragColor = texelColor;
        }
    </script>
    
    <script id="cornercolor-fs" type="x-shader/x-fragment">
        varying highp vec3 vObjNormal;

        void main(void) {
            highp vec4 texelColor;
            
            texelColor.rgb = ( clamp( vObjNormal.xyz * 2.0, vec3(-1.0), vec3(1.0)) + 1.0 ) * 0.5;
            texelColor.a = 1.0;
                        
            
            gl_FragColor = texelColor;
        }
    </script>
    
    
    <script id="voxel-fs" type="x-shader/x-fragment">
        varying highp vec3 vObjNormal;
        varying highp vec3 vColor;

        void main(void) {
            gl_FragColor = vec4( vColor, 1.0);
        }
    </script>

    <script id="position-fs" type="x-shader/x-fragment">
        varying highp vec3 vPosition;
        varying highp vec2 vUV;

        uniform highp float cubeSize;

        void main(void) {
            highp vec4 color;
            color.xyz = vPosition / 256.0;
            //color.xyz -= 1.0;
            color.a = 1.0;
            gl_FragColor = color;
        }

    </script>

    <script id="compose-fs" type="x-shader/x-fragment">
        uniform sampler2D uVoxTex;
        uniform sampler2D uPosTex;
        uniform sampler2D uShadowTex;

        uniform highp float cubeSize;       // 64.0
        uniform highp float layersPerRow;   // 8
        uniform highp float imageSize;      // 512

        uniform highp mat4 uLightSpace;
        uniform highp mat4 uCubeMat;

        uniform highp vec3 uLightPos;

        varying highp vec2 vTextureCoord;

         const highp float EPSILON = 0.004;

        highp float calcShadowFactor( highp vec3 lightPos )
        {
            highp float factor = 0.0;

            for( int x = -1; x <= 1; x++ )
            {
                for( int y = -1; y <= 1; y++ )
                {
                    highp vec4 shadowPos = texture2D(uShadowTex, lightPos.xy + vec2( x, y) * EPSILON );
                    
                    if( shadowPos.r < lightPos.z - 0.02 )
                    {
                        highp float off = min((lightPos.z - shadowPos.r) * 1.0, 1.0);
                        off = off + 0.7;
                        off *= off;
                        highp float lDist = lightPos.z;
                        lDist *= lDist;
                        off *= min( (1.0 + lDist*10.0 ) , 2.0);
                        factor += ( min( off, 1.0 ) * 0.7 ) + 0.3;
                    }
                }
            }

            factor = factor / 9.0;

            return factor;

        }

        void main(void) 
        {
            highp vec4 cubePos = texture2D(uPosTex, vTextureCoord.st);

            highp vec4 color = cubePos;

            cubePos.xyz = cubePos.xyz * ( 256.0);
            


            highp vec4 lightPos;


            if( cubePos.a > 0.0 )
            {
                
                highp vec2 uv = vec2( mod( cubePos.x, cubeSize ),  mod( floor(cubePos.y), cubeSize )) + vec2( floor( mod(cubePos.z, layersPerRow) ), floor(cubePos.z / layersPerRow) ) * cubeSize;
                uv /= imageSize; 

                if( cubePos.y > -64.0)
                {
                    color =  texture2D(uVoxTex, uv);
                }
                else
                {
                    color = vec4(1.0);    
                }

                cubePos.xyz -= vec3(cubeSize*0.5);

                lightPos = uLightSpace * uCubeMat * vec4( cubePos.xyz, 1.0);

            }
            else
            {
                color = vec4(1.0);

                cubePos.xyz = cubePos.xyz - vec3(128.0);

                lightPos = uLightSpace * vec4( cubePos.xyz, 1.0);
            }

            lightPos.xyz = lightPos.xyz / lightPos.w;

            lightPos.xyz = lightPos.xyz * 0.5 + 0.5;

            color.rgb *= 1.0 - calcShadowFactor(lightPos.xyz ) * 0.4;

            gl_FragColor = color; //vec4( ( cubePos.xyz + vec3(cubeSize * 0.5 ) ) / 256.0, 1.0);
        }

    </script>

    
    <script id="basic-vs" type="x-shader/x-vertex">       
        attribute highp vec3 aVertexPosition;

        uniform highp mat4 uNormalMatrix;
        uniform highp mat4 uMMatrix;
        uniform highp mat4 uVMatrix;
        uniform highp mat4 uPMatrix;

        uniform sampler2D uVoxTex;

        uniform highp float cubeSize; // 64.0
        uniform highp float layersPerRow; // 8
        uniform highp float imageSize; // 512

        varying highp vec3 vObjNormal;
        varying highp vec3 vColor;
        varying highp vec3 vPosition;
        varying highp vec2 vUV;

        void main(void) {

            highp vec3 cubePos = aVertexPosition + vec3(0.5, 0.5, 0.5 );
            cubePos.xyz = floor( cubePos.xyz / 2.0 );
            
            highp vec2 uv = vec2( mod( cubePos.x, cubeSize ), mod( cubePos.y, cubeSize ) ) + vec2(mod(cubePos.z, layersPerRow), floor(cubePos.z / layersPerRow) ) * cubeSize;
            highp vec4 col = texture2D(uVoxTex, uv / imageSize ).rgba;
            
            highp vec3 offset = aVertexPosition - cubePos * 2.0;          
                        
            highp vec3 pos = offset + cubePos - vec3(cubeSize * 0.5 );

            vPosition = cubePos ;
            vUV = uv;
            
            if( col.a <= 0.5 )
            {
                gl_Position = vec4(-1.0);
            }
            else
            {
                gl_Position = uPMatrix * uVMatrix * uMMatrix * vec4(pos, 1.0);
            }

            highp vec3 objNormal = normalize(aVertexPosition - cubePos * 2.0);

            vObjNormal = objNormal;
            
            vColor = col.rgb;
        }
    </script>

    <script id="floor-fs" type="x-shader/x-fragment">
        varying highp vec3 vPosition;
        varying highp vec2 vUV;

        uniform highp float cubeSize;

        void main(void) {
            highp vec4 color;
            color.xyz = ( vPosition + vec3(128.0)) / 256.0;
            //color.xyz -= 1.0;
            color.a = 0.0;
            gl_FragColor = color;
        }
    </script>

    <script id="floor-vs" type="x-shader/x-vertex">
        attribute highp vec3 aVertexPosition;

        uniform highp mat4 uMMatrix;
        uniform highp mat4 uVMatrix;
        uniform highp mat4 uPMatrix;

        varying highp vec3 vPosition;
        varying highp vec2 vUV;

        void main(void) {
                        
            highp vec3 pos = aVertexPosition;

            vPosition = pos;
            vUV = normalize(aVertexPosition).xz;
            
            gl_Position = uPMatrix * uVMatrix * vec4(pos, 1.0);
        }
    </script>


    <script id="sculpt2-fs" type="x-shader/x-fragment">
        uniform sampler2D uVoxTex;
        uniform sampler2D uPosTex;

        uniform highp mat4 uMMatrix;
        uniform highp mat4 uVMatrix;
        uniform highp mat4 uPMatrix;

        uniform highp vec3 uSculptDir;
        uniform highp vec3 uSculptPos;
        uniform highp vec3 uLastPos;

        uniform highp vec3 uMousePos;
        uniform highp vec3 uCamPos;

        uniform highp float uRadius;
        uniform highp float uDeltaTime;

        uniform highp float cubeSize;       // 64.0
        uniform highp float layersPerRow;   // 8
        uniform highp float imageSize;      // 512

        uniform highp vec2 uCanvasSize;

        varying highp vec2 vTextureCoord;

        highp vec2 closestPoint( highp vec2 a, highp vec2 b, highp vec2 p )
        {
            highp vec2 ap = p - a;
            highp vec2 ab = b - a;
            highp float ab2 = ab.x * ab.x + ab.y * ab.y;
            highp float ap_ab = ap.x * ab.x + ap.y * ab.y;
            highp float t = ap_ab / ab2;
            
            if( t < 0.0 ) t = 0.0;
            else if ( t > 1.0 ) t = 1.0;
            
            return a + ab * t;
        }

        void main(void) 
        {
            highp float spacing = 1.0/layersPerRow;
            
            highp vec3 cubePos;        
            cubePos.x = mod( vTextureCoord.x, spacing ) * layersPerRow;
            cubePos.y = mod( vTextureCoord.y, spacing ) * layersPerRow;
            cubePos.z = floor( vTextureCoord.x * layersPerRow ) + floor( vTextureCoord.y * layersPerRow ) * layersPerRow;   
   
            cubePos.xy *= cubeSize;

            cubePos.xyz = floor(cubePos.xyz);
            
            cubePos.xyz -= vec3(cubeSize*0.5);

            highp vec4 scrPos = uPMatrix * uVMatrix * uMMatrix * vec4(cubePos,1.0);
            scrPos.xy /= scrPos.w; 
            scrPos.xy = scrPos.xy * 0.5 + 0.5;

            scrPos.xy  = floor((scrPos.xy * imageSize) ) / imageSize; 
            highp vec4 smplPos = texture2D(uPosTex, scrPos.xy);
            smplPos = smplPos * 256.0;

            smplPos.xyz = floor(smplPos.xyz);
            
            highp vec4 vox = texture2D(uVoxTex, vTextureCoord);

            cubePos.xyz += vec3(cubeSize*0.5);

            cubePos.xyz = floor(cubePos.xyz);

            if( scrPos.z > -2.5 )
            {
                highp vec2 linePoint = closestPoint(uLastPos.xy, uMousePos.xy, scrPos.xy);

                highp float aspect = uCanvasSize.y / uCanvasSize.x;

                if( abs( scrPos.x - linePoint.x) < uRadius * aspect && abs(scrPos.y - linePoint.y ) < uRadius )
                {
                    highp float offset = length( cubePos.xyz - uCamPos.xyz ) - length( smplPos.xyz - uSculptPos.xyz);

                    if( offset <= 2.0 )
                    {
                        vox.a = 0.0;
                    }
                }

            }

            gl_FragColor = vox;
        }
    </script>

    
    <script id="paint2-fs" type="x-shader/x-fragment">
        uniform sampler2D uVoxTex;
        uniform sampler2D uPosTex;

        uniform highp mat4 uMMatrix;
        uniform highp mat4 uVMatrix;
        uniform highp mat4 uPMatrix;

        uniform highp vec3 uSculptDir;
        uniform highp vec3 uSculptPos;
        uniform highp vec3 uLastPos;

        uniform highp vec3 uMousePos;
        uniform highp vec3 uCamPos;

        uniform highp float uRadius;
        uniform highp float uDeltaTime;

        uniform highp vec3 uToolColor;

        uniform highp float cubeSize;       // 64.0
        uniform highp float layersPerRow;   // 8
        uniform highp float imageSize;      // 512

        uniform highp vec2 uCanvasSize;

        varying highp vec2 vTextureCoord;

        

        highp vec2 closestPoint( highp vec2 a, highp vec2 b, highp vec2 p )
        {
            highp vec2 ap = p - a;
            highp vec2 ab = b - a;
            highp float ab2 = ab.x * ab.x + ab.y * ab.y;
            highp float ap_ab = ap.x * ab.x + ap.y * ab.y;
            highp float t = ap_ab / ab2;
            
            if( t < 0.0 ) t = 0.0;
            else if ( t > 1.0 ) t = 1.0;
            
            return a + ab * t;
        }

        void main(void) 
        {
            highp float spacing = 1.0/layersPerRow;
            
            highp vec3 cubePos;        
            cubePos.x = mod( vTextureCoord.x, spacing ) * layersPerRow;
            cubePos.y = mod( vTextureCoord.y, spacing ) * layersPerRow;
            cubePos.z = floor( vTextureCoord.x * layersPerRow ) + floor( vTextureCoord.y * layersPerRow ) * layersPerRow;   
   
            cubePos.xy *= cubeSize;

            cubePos.xyz = floor(cubePos.xyz);
            
            cubePos.xyz -= vec3(cubeSize*0.5);

            highp vec4 scrPos = uPMatrix * uVMatrix * uMMatrix * vec4(cubePos,1.0);
            scrPos.xy /= scrPos.w; 
            scrPos.xy = scrPos.xy * 0.5 + 0.5;

            scrPos.xy  = floor((scrPos.xy * imageSize) ) / imageSize; 
            highp vec4 smplPos = texture2D(uPosTex, scrPos.xy);
            smplPos = smplPos * 256.0;


            smplPos.xyz = floor(smplPos.xyz);
            
            highp vec4 vox = texture2D(uVoxTex, vTextureCoord);

            cubePos.xyz += vec3(cubeSize*0.5);

            cubePos.xyz = floor(cubePos.xyz);

            if( scrPos.z > -2.5 )
            {
                highp vec2 linePoint = closestPoint(uLastPos.xy, uMousePos.xy, scrPos.xy);

                highp float aspect = uCanvasSize.y / uCanvasSize.x;

                if( abs( scrPos.x - linePoint.x) < uRadius * aspect && abs(scrPos.y - linePoint.y ) < uRadius )
                {
                    highp float offset = length( cubePos.xyz - uCamPos.xyz ) - length( smplPos.xyz - uSculptPos.xyz);

                    if( offset <= 2.0 )
                    {
                        vox.rgb = uToolColor.rgb;
                    }
                }

            }

            gl_FragColor = vox;
        }

    </script>
    
    <script id="sculpt-fs" type="x-shader/x-fragment">
        varying highp vec2 vTextureCoord;

        uniform sampler2D uVoxTex;
        uniform highp vec3 uSculptDir;
        uniform highp vec3 uLastDir;
        uniform highp vec3 uSculptPos;
        uniform highp vec3 uLastPos;

        uniform highp float uRadius;
        uniform highp float uDeltaTime;

        uniform highp float cubeSize; // 64.0
        uniform highp float layersPerRow; // 8
        uniform highp float imageSize; // 512
        
        highp float rand(highp vec2 co){
            return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
        }
        
        highp vec3 closestPoint( highp vec3 a, highp vec3 b, highp vec3 p )
        {
            highp vec3 ap = p - a;
            highp vec3 ab = b - a;
            highp float ab2 = ab.x * ab.x + ab.y * ab.y;
            highp float ap_ab = ap.x * ab.x + ap.y * ab.y;
            highp float t = ap_ab / ab2;
            
            if( t < 0.0 ) t = 0.0;
            else if ( t > 1.0 ) t = 1.0;
            
            return a + ab * t;
        }

        void main(void) {
            highp vec4 vox = texture2D(uVoxTex, vTextureCoord.st);
            
            
            // vec2( mod( cubePos.x, 64.0 ), mod( cubePos.z, 64.0 ) ) + vec2(mod(cubePos.y, 8.0), floor(cubePos.y / 8.0) ) * 64.0;
            
            highp float spacing = 1.0/layersPerRow;
            
            highp vec3 pos;        
            pos.x = mod( vTextureCoord.x, spacing ) * layersPerRow;
            pos.y = mod( vTextureCoord.y, spacing ) * layersPerRow;
            pos.z = floor( vTextureCoord.x / spacing ) + floor( vTextureCoord.y / spacing ) * layersPerRow;   
                                
            pos.xy *= cubeSize;
            
            //vox.rgb = pos.xyz / 64.0;
                        
            pos.xyz -= vec3(cubeSize*0.5);
           
            //vox.rgb = vec3(0.1, 0.8, 0.1) * max( abs(pos.x), max( abs( pos.y ), abs(pos.z) ) ) / 32.0 ;
                        
            
            highp vec3 cubeOff = ( pos - uSculptPos );
            highp vec3 cubeOffN = normalize( cubeOff );
            
            highp vec3 fixedDir = closestPoint( normalize( uLastDir ), normalize( uSculptDir ), cubeOffN );
            
            
            highp vec3 sculptDir = normalize(fixedDir );
            
            highp float cosAng = dot( cubeOffN, sculptDir );
            
            highp float offLength = length( cubeOff );

            if( cosAng >= 0.0 )
            {
                highp float dist = offLength * sin( acos( cosAng ) );
                if( dist <= uRadius )
                {
                    for( int i=0; i < 3; i++ )
                    {
                        highp vec3 off;
                        if( i == 0 )
                        {
                            if( sculptDir.x == 0.0 )
                                continue;
                            off = vec3( sign(sculptDir.x), 0.0, 0.0);
                        }
                        else if ( i == 1 )
                        {
                            if( sculptDir.y == 0.0 )
                                continue;
                            off = vec3( 0.0, sign(sculptDir.y), 0.0);                   
                        }
                        else if ( i == 2 )
                        {
                            if( sculptDir.z == 0.0 )
                                continue;
                            off = vec3( 0.0, 0.0, sign(sculptDir.z));                    
                        }
                        
                        highp vec3 frontPos = pos - off;
                        frontPos += vec3(cubeSize*0.5);
                        
                        highp vec2 uv = frontPos.xy + vec2(mod(frontPos.z, layersPerRow), floor(frontPos.z / layersPerRow) ) * cubeSize;
                        
                        uv = uv / imageSize;              
                        
                        bool outOfRange = frontPos.x < 0.0 || frontPos.x > cubeSize ||
                                            frontPos.y < 0.0 || frontPos.y > cubeSize ||
                                            frontPos.z < 0.0 || frontPos.z > cubeSize - 1.0;
                        
                        if(outOfRange ||  texture2D(uVoxTex, uv ).a <= 0.5 )
                        {
                            vox.a = 0.0;
                        }
                    }
                }  
            }                   

            gl_FragColor = vox;
        }
    </script>   

    
    <script id="paint-fs" type="x-shader/x-fragment">
        varying highp vec2 vTextureCoord;

        uniform sampler2D uVoxTex;
        uniform highp vec3 uSculptDir;
        uniform highp vec3 uSculptPos;

        uniform highp float uRadius;
        uniform highp float uDeltaTime;

        uniform highp float cubeSize; // 64.0
        uniform highp float layersPerRow; // 8
        uniform highp float imageSize; // 512
        
        highp float rand(highp vec2 co){
            return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
        }

        void main(void) {
            highp vec4 vox = texture2D(uVoxTex, vTextureCoord.st);
            
            
            // vec2( mod( cubePos.x, 64.0 ), mod( cubePos.z, 64.0 ) ) + vec2(mod(cubePos.y, 8.0), floor(cubePos.y / 8.0) ) * 64.0;
            
            highp float spacing = 1.0/layersPerRow;
            
            highp vec3 pos;        
            pos.x = mod( vTextureCoord.x, spacing ) * layersPerRow;
            pos.y = mod( vTextureCoord.y, spacing ) * layersPerRow;
            pos.z = floor( vTextureCoord.x / spacing ) + floor( vTextureCoord.y / spacing ) * layersPerRow;   
                                
            pos.xy *= cubeSize;
            
            //vox.rgb = pos.xyz / 64.0;
                        
            pos.xyz -= vec3(cubeSize*0.5);
           
            //vox.rgb = vec3(0.1, 0.8, 0.1) * max( abs(pos.x), max( abs( pos.y ), abs(pos.z) ) ) / 32.0 ;
                        
            highp vec3 cubeOff = ( pos - uSculptPos );
            
            highp vec3 sculptDir = normalize(uSculptDir );
            
            highp float cosAng = dot( normalize( cubeOff ), sculptDir );
            
            highp float offLength = length( cubeOff );

            if( cosAng >= 0.0 )
            {
                highp float dist = offLength * sin( acos( cosAng ) );
                if( dist <= uRadius )
                {
                    for( int i=0; i < 3; i++ )
                    {
                        highp vec3 off;
                        if( i == 0 )
                        {
                            if( sculptDir.x == 0.0 )
                                continue;
                            off = vec3( sign(sculptDir.x), 0.0, 0.0);
                        }
                        else if ( i == 1 )
                        {
                            if( sculptDir.y == 0.0 )
                                continue;
                            off = vec3( 0.0, sign(sculptDir.y), 0.0);                   
                        }
                        else if ( i == 2 )
                        {
                            if( sculptDir.z == 0.0 )
                                continue;
                            off = vec3( 0.0, 0.0, sign(sculptDir.z));                    
                        }
                        
                        highp vec3 frontPos = pos - off;
                        frontPos += vec3(cubeSize*0.5);
                        
                        highp vec2 uv = frontPos.xy + vec2(mod(frontPos.z, layersPerRow), floor(frontPos.z / layersPerRow) ) * cubeSize;
                        
                        uv = uv / imageSize;              
                        
                        bool outOfRange = frontPos.x < 0.0 || frontPos.x > cubeSize ||
                                            frontPos.y < 0.0 || frontPos.y > cubeSize ||
                                            frontPos.z < 0.0 || frontPos.z > cubeSize - 1.0;
                        
                        if(outOfRange ||  texture2D(uVoxTex, uv ).a <= 0.5 )
                        {
                            vox.rgb = vec3(1.0, 0.0, 0.0);
                        }
                    }
                }  
            }                   

            gl_FragColor = vox;
        }
    </script>  

    <script id="screenquad-vs" type="x-shader/x-vertex">
        attribute highp vec3 aVertexPosition;

        varying highp vec2 vTextureCoord;

        void main(void)
        {
            gl_Position = vec4(aVertexPosition.xy, 1.0, 1.0);
            vTextureCoord = (aVertexPosition.xy + vec2(1.0)) * 0.5;
        }
    </script>


    <script id="copy-fs" type="x-shader/x-fragment">
        varying highp vec2 vTextureCoord;

        uniform sampler2D uCopyTex;

        void main(void) {
            highp vec4 col = texture2D(uCopyTex, vTextureCoord.st);
            gl_FragColor = col;
        }
    </script>

    <script id="initdata-fs" type="x-shader/x-fragment">
        varying highp vec2 vTextureCoord;

        uniform highp float cubeSize; // 64.0
        uniform highp float layersPerRow; // 8
        uniform highp float imageSize; // 512

        highp float rand(highp vec2 co){
            return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
        }

        void main(void) {
            //highp float startLife = rand(vTextureCoord.st) + 1.0;
            highp float spacing = 1.0/layersPerRow;
            
            highp vec3 pos;        
            pos.x = mod( vTextureCoord.x, spacing ) * layersPerRow;
            pos.y = mod( vTextureCoord.y, spacing ) * layersPerRow;
            pos.z = floor( vTextureCoord.x / spacing ) + floor( vTextureCoord.y / spacing ) * layersPerRow;   
                                
            pos.xy *= cubeSize;
            
                        
            pos.xyz -= vec3(cubeSize*0.5);
           
            highp vec4 col;
            col.rgb = vec3(0.1, 0.8, 0.1) * (( max( abs(pos.x), max( abs( pos.y ), abs(pos.z) ) ) / (cubeSize*0.5) ) * 0.5 + 0.5 );
            col.a = 1.0;
            gl_FragColor = vec4( 0.2, 0.9, 0.2, 1.0); //scol;
        }
    </script>
</head>

<body onload="start()" style="margin: 0px;touch-action: none;">



    <div class="container">
        <canvas id="glcanvas" width="1200" height="480" style="width:100%;height:100%;cursor:crosshair;">
            Your browser doesn't appear to support the <code>&lt;canvas&gt;</code> element.
        </canvas>
        <div id="overlay">                       
            <div style="display:none;">Load Voxel Data from Image <input id="fileItem" type="file"></div>
            </div>
                
            </div>
            <script type="text/javascript">
                var obj = {

                    tool: 'sculpt',
                    brushSize: 0.04,
                    paintColor: "#ffae23",
                    loadData: function () {
                        document.getElementById("fileItem").click();
                    }

                };

                var gui = new dat.gui.GUI();

                // Choose from accepted values
                gui.add(obj, 'tool', [ 'sculpt', 'paint' ] ).onFinishChange(function(value){
                    var toolIndex = 0;
                    switch( value )
                    {
                        case "sculpt":
                        toolIndex = 0;
                        break;

                        case "paint":
                        toolIndex = 1;
                        break;
                    }

                    setToolShader(toolIndex);
                });

                gui.add(obj, 'brushSize').min(0.01).max(0.1).step(0.001).onChange(function(value) {
                    changeBrushSize(value);
                });


                //var f1 = gui.addFolder('Colors');
                gui.addColor(obj, 'paintColor').onChange(function(value) {
                  changePaintColor(value);
                });

                gui.add(obj, 'loadData');


            </script>
        </div>
    </div>

 <style>
        #overlayTutorial {
            position: fixed; /* Sit on top of the page content */
            display: none; /* Hidden by default */
            width: 100%; /* Full width (cover the whole page) */
            height: 100%; /* Full height (cover the whole page) */
            top: 0; 
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0,0,0,0.5); /* Black background with opacity */
            z-index: 2; /* Specify a stack order in case you're using a different order for other elements */
            cursor: pointer; /* Add a pointer on hover */
        }

        #overlaytext{
            position: absolute;
            top: 50%;
            left: 50%;
            font-size: 50px;
            color: white;
            transform: translate(-50%,-50%);
            -ms-transform: translate(-50%,-50%);
        }
</style>

<div id="overlayTutorial" onclick="tutorialOff()">
    <div id="overlaytext">Sculpt: Left Click <br/>Rotate: Right Click <br />Zoom: Alt + Right Click</div>
</div>   

</body>
</html>